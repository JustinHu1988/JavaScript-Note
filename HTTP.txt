第6章 HTTP首部
	
6.1 HTTP报文首部
	首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。

	报文首部由以下几个字段构成：
		
		1. HTTP请求报文：
			方法（例如GET或POST）
			URI
			HTTP版本
			HTTP首部字段（请求、通用、实体）等
		
		2. HTTP响应报文：
			HTTP版本
			状态码（数字和原因短语）
			HTTP首部字段（响应、通用、实体）等


6.2 HTTP首部字段

	6.21 传递重要信息：给浏览器和服务器提供报文主体大小，所使用的语言，认证信息等。

	6.22 结构：
		1. 首部字段由首部字段名和字段值构成，中间用冒号“:”分隔。即 首部字段名:字段值

			例：用Content-Type字段来表示报文主体的对象类型
				Content-Type: text/html

		2. 此外，对应单个HTTP首部字段，可以有多个值：

			例：Keep-Alive: timeout=15, max=100

		3. 若HTTP首部字段重复会怎样？目前浏览器的处理方式尚无统一标准。

	6.23 4种类型
		1.通用首部字段（General Header Fields）
			请求报文和响应报文两方都会使用的首部。
		2.请求首部字段（Request Header Fields）
			从客户端向服务端发请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。
		3.响应首部字段（Response Header Fields）
			从服务端向客户端发送请求报文时使用的首部，补充了响应的附加内容、也会要求客户端附加额外的内容信息。
		4.实体首部字段（Entity Header Fields）
			针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的信息。

	6.24 HTTP/1.1 首部字段：共47种。见P80

	6.25 非HTTP/1.1 首部字段

	6.26 End-to-end首部和Hop-by-hop首部
		HTTP首部字段将定义成缓存代理和非缓存代理的行为，分成2种类型。

			端到端首部（End-to-end Header）
				转发给请求/响应对应的最终接收目标，也必须保存在由缓存生成的响应中，另外规定它必须转发。

			逐跳首部（Hop-by-hop Header）
				分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。如果需要使用hop-by-hop首部，需提供Connection首部字段。共有8个首部字段。见P83

6.3 HTTP/1.1通用首部字段
	请求报文和响应报文两方都会使用的首部。

	6.31 









7 确保Web安全的HTTPS

7.1 HTTP的缺点
	1. 通信使用明文（不加密），内容可能会被窃听。
	2. 不验证通信方的身份，因此有可能遭遇伪装。
	3. 无法证明报文的完整性，有可能已遭篡改。
	Web服务器和特定的Web浏览器在实际应用中存在不足（脆弱性、安全漏洞），另外用Java和PHP等编程语言开发的Web应用也可能存在安全漏洞。

	7.11 通信使用明文可能会被窃听
		1. TCP/IP是可能被窃听的网络
			按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。
			即使已经过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是如果通信经过加密，就有可能让人无法破解报文信息的含义，不过加密处理后的报文信息本身还是会被看到的。

			窃听相同段上的通信并非难事。只需要收集在互联网上流动的数据包就行。对于收集来的数据包的解析工作，可交给那些抓包或嗅探器工具。

		2. 加密处理防止被窃听
			加密对象有：
				1. 通信的加密
					可以通过和SSL或TLS的组合使用，加密HTTP的通信内容。
					与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL。
				2. 内容的加密
					由于HTTP协议中没有加密机制，那可以把HTTP报文里所含的内容进行加密处理。（但仍有被篡改的风险）

	7.12 不验证通信方的身份，就可能遭遇伪装。
		HTTP协议中的请求和响应不会对通信方进行确认。

		1. 任何人都可以发起请求
			服务器只要接收到请求，不管对方是谁都会返回一个响应（仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）。
			这有以下隐患：
				1. 无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器，有可能是已伪装的Web服务器。
				2. 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端，有可能是已伪装的客户端。
				3.无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限。
				4. 无法判定请求来自何方、出自谁手。
				5. 即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击（Denial of Service，拒绝服务攻击）。
		
		2. 查明对手的证书
			虽然使用HTTP协议无法确定通信方，但使用SSL则可以。
			SSL不仅提供加密处理，还使用了一种被称为证书的手段，可以用于确定通信方。
			证书由值得信任的第三方机构颁发，用于证明服务器和客户端是实际存在的。另外，伪造证书从技术角度十分困难。所以，只要能够确认通信方（服务器或客户端）持有的证书，即可以判断通信方的真实意图。
			客户端持有证书即可完成个人身份的确认，也可以用于对Web网站的认证环节。


	7.13 无法证明报文完整性，可能已遭篡改
		完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。

		1. 接收到的内容可能有误
			在请求或响应的途中，遭攻击者拦截并篡改内容的攻击，成为中间人攻击（Man-in-the-Middle attack, MITM）。

		2. 如何防止篡改
			使用HTTP协议确定报文完整性的方法：
				1. 常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。
				2. 提供文件下载服务的Web网站也会提供相应的以PGP（Pretty Good Privacy，完美隐私）创建的数字签名及MD5算法生成的散列值。PGP是用来证明创建文件的数字签名，MD5是由单向函数生成的散列值。
					不论用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。
			不过，这些方法无法百分百保证确认结果正确。如果PGP和MD5本身被改写，用户无法知道。

			为此，需要使用HTTPS。SSL提供认证和加密处理及摘要功能。


7.2 HTTP+加密+认证+完整性保护=HTTPS
		
	7.21 如果在HTTP协议通信过程中使用未经加密的明文，比如在Web页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。
		经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用http://,而是改用https://
		另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标记。

	7.22 HTTPS是身披SSL外壳的HTTP
		HTTPS并非是应用层的新协议，只是HTTP通信接口部分用SSL（Secure Socker Layer）和TLS（Transport Layer Security）协议代替。

		通常，HTTP直接和TCP通信。当使用SSL时，则先和SSL通信，再由SSL和TCP通信。

		不只是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。SSL是当今应用最为广泛的网络安全技术。

	7.23 相互交换密钥的公开密钥加密技术
		SSL采用公开密钥加密（Public-key cryptography）的加密处理方式。

		近代的加密方法中，加密算法是公开的，而密钥却是保密的。通过密钥来保持加密方法的安全性。

		1. 共享密钥加密的困境：
			以共享密钥方式加密时，必须将密钥也发给对方。但如果密钥落入攻击者手中，加密将失去意义。

		2.使用两把密钥的公开密钥加密
			公开密钥加密方式解决了共享密钥加密的困境。

			公开密钥加密使用一对非对称的密钥，一把叫做私有密钥（private），另一把叫做公开密钥（public key）。私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。

		3. HTTPS采用混合加密机制：
			HTTPS采用共享密钥加密和公开密钥加密并用。公开密钥加密与共享密钥加密相比，处理速度要慢。
			应充分利用两者各自的优势：在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段，则使用共享密钥加密方式。

			注：公开密钥加密处理起来比共享密钥加密方式更为复杂，通信中效率较低。

	7.24 证明公开密钥正确性的证书
		公开密钥加密也存在一些问题：无法证明公开密钥本身就是货真价实的公开密钥。（例如在公开密钥传输途中被攻击者替换）

		为此，需要使用由数字证书认证机构（CA,Certificate Authority）和其相关机关颁发的公开密钥证书。

		认证机构对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。
		服务器会将这份由认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。而公钥证书也可以叫做数字证书或直接成为证书。

		接到证书的客户端可使用数字证书认证机构的公开密钥，对证书上的数字签名进行验证。如果验证通过，说明认证服务器公开密钥的是正规数字证书认证机构，也说明服务器的公开密钥是可信赖的。

		那么又有一个问题，数字认证机构的公开密钥必须安全转交给客户端。使用通信方式时，如何安全转交是件很困难的事。因此多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。

		

		1. 可证明组织真实性的EV SSL证书
			证书的作用：
				证明通信方的服务器是否规范
				确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是EV SSL证书（Extended Validation SSL Certificate）。通过认证的Web网站能够获得更高的认可度。

		2. 用以确认客户端的客户端证书


......



第8章 确认访问用户身份的认证

8.1 认证登陆者身份时，核对的信息通常是：
	1. 密码
	2. 动态令牌
	3. 数字证书
	4. 生物认证
	5. IC卡等

	不能让他人获取到密码（不能轻易被破解出来）。

	HTTP使用的认证方式：
		1. BASIC认证（基本认证）
		2. DIGEST认证（摘要认证）
		3. SSL客户端认证
		4. FormBase认证（基于表单认证）
	此外，还有Windows统一认证（Keberos认证、NTLM认证）。


8.2 BASIC认证
	问题：
		1. Base编码方式明文发送，不安全
		2. 无法实现认证注销

8.3 DIGEST认证
	弥补BASIC认证的弱点，不发送明文密码。



	......





第9章 基于HTTP的功能追加协议

9.2 消除HTTP瓶颈的SPDY
	
	9.21 HTTP的瓶颈
		1. 一条连接上只可发送一个请求
		2. 请求只能从客户端开始。客户端不可以接收除响应以外的指令。
		3. 请求/响应首部未经压缩就发送。首部信息越多，延迟越大。
		4. 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。
		5. 可任意选择数据压缩格式。非强制压缩发送。

	Ajax的解决方法
		Ajax(Asynchronous JavaScript and XML，异步JavaScript与XML技术)是一种有效利用JavaScript和DOM的操作，已达到局部Web页面替换加载的异步通信手段。由于只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。
		不过，利用Ajax实时从服务器获取内容，有可能导致大量请求产生。另外，Ajax仍未解决HTTP协议本身存在的问题。

	Comet解决方法
		一旦服务端有内容更新，Comet不会让请求等待，而是直接给客户端返回响应。（延迟应答）
		通常服务器端接受到请求，在处理完毕后会立即返回响应。但为了实现推送功能，Comet会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。

		但是，虽然能做到内容实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet也仍未解决HTTP协议本身存在的问题。

	SPDY的目标
		为了在协议级别消除HTTP所遭遇的瓶颈。


	9.22 SPDY的设计与功能

		SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。

		SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信链接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文。
			HTTP 应用层
			SPDY 会话层
			SSL  表示层
			TCP  传输层


		使用SPDY后，HTTP协议额外获得以下功能：

			1. 多路复用流
				通过单一的TCP连接，可以无限制处理多个HTTP请求。
			2. 赋予请求优先级
				SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。主要用于解决在发送多个请求时，解决因带宽低而导致响应变慢的问题。
			3. 压缩HTTP首部
				压缩HTTP请求和响应的首部。
			4. 推送功能
				支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。
			5. 服务器提示功能
				服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前，就可以获知资源的存在，因此在资源已缓存的情况下，可以避免发送不必要的请求。

	9.23 SPDY消除Web瓶颈了吗？
		SPDY基本上只是将单个域名（IP地址）的通信多路复用，所以当一个Web网站上使用多个域名下的资源，改善效果就会受到限制。


9.3 使用浏览器进行全双工通信的WebSocket

	WebSocket网络技术是为了解决HTTP协议瓶颈而实现的一套新协议及API。

	9.31 WebSocket的设计与功能
		WebSocket，即Web浏览器和Web服务器之间全双工通信标准。
		其中，WebSocket协议由IETF定位标准，WebSocket API由W3C定位标准。仍在开发中的WebSocket技术主要是为了解决Ajax和Comet里XMLHttpRequest附带的缺陷所引起的问题。

 	9.32 WebSocket协议
 		一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。

 		由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端。不过一旦确立WebSocket通信连接，服务器和客户端都可以直接向对方发送报文。

 		主要特点：
 			1. 推送功能
 			2. 减少通信量
 				只要建立起WebSocket链接，就希望一直保持连接状态。与HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也响应减少了。

 		握手·请求：
 			为了实现WebSocket通信，需要用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变，以达到握手的目的。
 			Upgrade: websocket

 			Sec-WebSocket-Key字段内记录着握手过程中必不可少的键值。
 			Sec-WebSocket-Protocol字段内记录使用的子协议。

 		握手·响应：
 			对于之前的请求，返回状态码101 Switching Protocols的响应。
 			即：
 				HTTP/1.1 101 Switching Protocols
 				Upgrade: websocket
 				Connection: Upgrade
 				Sec-WebSocket-Accept: （此处有字段值）
 				Sec-WebSocket-Protocol: chat
 			Sec-WebSocket-Accept的字段值是由握手请求中的Sec-WebSocket-Key字段值生成的。

 			成功握手确立WebSocket连接之后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。

 		*WebSocket API
 			JavaScript可调用“The WebSocket API”（由W3C标准制定）内提供的WebSocket程序接口，实现WebSocket协议下全双工通信。
 				例：
 					var socket = new WebSocket('ws://game.example.com:12010/updates');
 					socket.onopen = function(){
 						setInterval(function(){
 							if (socket.bufferedAmount == 0) {
 								socket.send(getUpdateData());
 							}
 						},50);
 					};
 					//每50ms发送一次数据的实例


9.4 HTTP/2.0

9.5 Web服务器管理文件WebDAV

	



第10章 构建Web内容的技术


第11章 Web的攻击技术
	在客户端即可篡改请求

	针对Web应用的攻击模式
		主动攻击（active attack）：攻击者直接访问Web应用，把攻击代码传入的攻击模式。例如SQL注入攻击和OS命令注入攻击。
		被动攻击（passive attack）：利用圈套策略执行攻击代码的攻击模式。例如跨站脚本攻击和跨站点请求伪造。

	利用用户的身份攻击企业内部网络：
		利用被动攻击，可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。只要用户踏入攻击者预先设好的陷阱，在用户能够访问到的网络范围内，即使是企业内网，也同样会受到攻击。


11.2 因输出值转义不完全引发的安全漏洞：
	
	实施Web应用的安全对策可大致分为以下两部分：
		1. 客户端验证
		2. Web应用端（服务器端）的验证
			输入值验证
			输出值转义

	11.21 跨站脚本攻击（Cross-Site Scripting, XSS）是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。
		动态创建的HTML部分有可能隐藏着安全漏洞，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。

		跨站脚本攻击有可能造成以下影响：
			利用虚假输入表单骗取用户个人信息。
			利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。
			显示伪造的文章或图片。

		XSS是攻击者利用预先设置的陷阱触发的被动攻击


	11.22 SQL注入攻击
		SQL注入（SQL Injection）是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。有可能直接导致个人信息和机密信息的泄露。


	11.23 OS命令注入攻击（OS Command Injection）
		指通过Web应用执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就存在被攻击的风险。

		可以从Web应用中通过Shell来调用操作系统命令。若调用Shell时存在疏漏，就可以执行插入的非法OS命令。

	11.24 HTTP首部注入攻击
		







	

















